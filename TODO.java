//Revisit LeetCode as you only did Partial:
1)https://leetcode.com/problems/max-area-of-island/
2) https://leetcode.com/problems/friends-of-appropriate-ages/
3) https://leetcode.com/problems/balanced-binary-tree/
4) https://leetcode.com/problems/heaters/ ---> Binary search easy question
5) https://leetcode.com/problems/numbers-with-same-consecutive-differences/ ---> medium


//Balanced Binary Tree
https://leetcode.com/articles/balanced-binary-tree/#

//Multi Threading in java: obect level locking(mainly for non static member and non static member functions) by synchronizing using a lock
//class level locking(for static member and static member function)
//https://howtodoinjava.com/java/multi-threading/object-vs-class-level-locking/

https://www.geeksforgeeks.org/median-of-stream-of-integers-running-integers/
https://www.youtube.com/watch?v=1CxyVdA_654

Medium: https://leetcode.com/problems/sum-of-subarray-minimums
https://leetcode.com/discuss/interview-question/275785/Facebook-or-Phone-screen-or-Count-subsets
good solution try : https://leetcode.com/playground/8QTQRWXA
https://leetcode.com/discuss/interview-question/268604/Google-interview-Number-of-subsets

https://www.geeksforgeeks.org/sum-of-all-subarrays/ O(n)
Just finding subarray's is with a formula a[i] *(n-i)+ (i+1)

Easy :https://leetcode.com/problems/verifying-an-alien-dictionary/

1) https://www.geeksforgeeks.org/generate-cyclic-permutations-number/
The idea is to generate next permutation of a number using below formula.
    rem = num % 10;
    div = num / 10;
    num = (pow(10, n - 1)) * rem + div;


Tree: Delete a node in a BST
https://www.geeksforgeeks.org/binary-search-tree-set-2-delete/

Tree Lowest Common Ancestor
https://www.youtube.com/watch?v=6Q7OrMi0Vvc
https://www.algoexpert.io/rachit

Tree Diameter of Tree for each Node as Root
https://www.youtube.com/watch?v=Xng1Od_v6Ug

Tree MaxPathSum:
https://www.youtube.com/watch?v=gm4Ye0fESpU
